use std::{
    fs::{self, File, OpenOptions},
    io::{self, BufRead, BufReader, Write},
};

use risc0_zkp::core::digest::Digest;

use crate::{data_layout, decode_hex_id, path_from_env, PROJECT_ROOT};

data_layout!(GuestIdLayout {
    project_root: PROJECT_ROOT.into(),
    out_dir: path_from_env("OUT_DIR").unwrap(),
} {
    (project_root / "rust/guest_wrapper/artifacts") => artifacts_dir,
    (artifacts_dir / "chain_guest/elf_id") => chain_guest_id,
    (artifacts_dir / "chain_guest/elf_id_history") => chain_guest_history,
    (out_dir / "guest_id.rs") => rust_guest_id,
});
pub struct ChainGuestId {
    layout: GuestIdLayout,
}

impl Default for ChainGuestId {
    fn default() -> Self {
        Self {
            layout: GuestIdLayout::new().unwrap(),
        }
    }
}

impl ChainGuestId {
    pub fn new() -> Self {
        Self::default()
    }

    fn current_id_hex(&self) -> anyhow::Result<String> {
        let path = self.layout.chain_guest_id();
        println!("cargo::rerun-if-changed={}", path.display());
        Ok(fs::read_to_string(path)?)
    }

    fn id_history_hex(&self) -> anyhow::Result<Vec<String>> {
        let path = self.layout.chain_guest_history();
        println!("cargo::rerun-if-changed={}", path.display());
        let file = File::open(path)?;
        let reader = BufReader::new(&file);
        Ok(reader.lines().collect::<io::Result<Vec<String>>>()?)
    }

    pub fn assert(&self, generated_id: Digest) -> anyhow::Result<()> {
        let current_id = self.current_id_hex()?;
        let generated_id = hex::encode(generated_id.as_bytes());
        anyhow::ensure!(
            generated_id == current_id,
            "Chain guest ELF ID mismatch. Run with `UPDATE_GUEST_ELF_ID=1` to update."
        );
        Ok(())
    }

    pub fn update(&self, new_id: Digest) -> anyhow::Result<()> {
        let old_hex_id = self.current_id_hex()?;
        let new_hex_id = hex::encode(new_id.as_bytes());

        if old_hex_id == new_hex_id {
            return Ok(());
        }
        fs::write(self.layout.chain_guest_id(), &new_hex_id)?;

        let history = self.id_history_hex()?;
        if history.iter().any(|id| id == &new_hex_id) {
            return Ok(());
        }

        let history_file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(self.layout.chain_guest_history())?;
        writeln!(&history_file, "{old_hex_id}")?;

        Ok(())
    }

    pub fn generate_rust(&self) -> anyhow::Result<()> {
        let current_id = decode_hex_id(self.current_id_hex()?)?;
        let history = self
            .id_history_hex()?
            .into_iter()
            .map(decode_hex_id)
            .collect::<anyhow::Result<Vec<Digest>>>()?;

        let file = File::create(self.layout.rust_guest_id())?;
        writeln!(&file, "// Chain guest ELF IDs. Auto-generated by build script.\n")?;
        writeln!(&file, "pub const CHAIN_GUEST_ELF_ID: [u8; 32] = {:?};\n", current_id.as_bytes())?;
        writeln!(&file, "pub const CHAIN_GUEST_OLD_ELF_IDS: [[u8; 32]; {}] = [", history.len())?;
        for old_id in history {
            writeln!(&file, "    {:?},", old_id.as_bytes())?;
        }
        writeln!(&file, "];")?;

        Ok(())
    }
}
