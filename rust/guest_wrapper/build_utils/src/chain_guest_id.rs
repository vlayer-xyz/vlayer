use std::{
    fs::{self, File, OpenOptions},
    io::{self, BufRead, BufReader, Write},
};

use lazy_static::lazy_static;
use risc0_zkp::core::digest::Digest;

use crate::{data_layout, decode_hex_id, path_from_env, PROJECT_ROOT};

data_layout!(Layout {
    project_root: PROJECT_ROOT.into(),
    out_dir: path_from_env("OUT_DIR").unwrap(),
} {
    (project_root / "rust/guest_wrapper/artifacts") => artifacts_dir,
    (artifacts_dir / "chain_guest/elf_id") => chain_guest_id,
    (artifacts_dir / "chain_guest/elf_id_history") => chain_guest_history,
    (artifacts_dir / "chain_guest/CHANGELOG.md") => chain_guest_changelog,
    (out_dir / "guest_id.rs") => rust_guest_id,
});

lazy_static! {
    static ref LAYOUT: Layout = Layout::new().unwrap();
}

fn current_id_hex() -> anyhow::Result<String> {
    let path = LAYOUT.chain_guest_id();
    println!("cargo::rerun-if-changed={}", path.display());
    Ok(fs::read_to_string(path)?)
}

fn id_history_hex() -> anyhow::Result<Vec<String>> {
    let path = LAYOUT.chain_guest_history();
    println!("cargo::rerun-if-changed={}", path.display());
    let file = File::open(path)?;
    let reader = BufReader::new(&file);
    Ok(reader.lines().collect::<io::Result<Vec<String>>>()?)
}

/// Assert that `generated_id` is identical to the chain guest ID stored in repo.
pub fn assert(generated_id: Digest) -> anyhow::Result<()> {
    let current_id = current_id_hex()?;
    let generated_id = hex::encode(generated_id.as_bytes());
    anyhow::ensure!(
        generated_id == current_id,
        "Chain guest ELF ID mismatch. Run with `UPDATE_GUEST_ELF_ID=1` to update."
    );
    Ok(())
}

/// Update the chain guest ID stored in repo to `new_id`, and append the previous one
/// to the file with ELF ID history.
pub fn update(new_id: Digest) -> anyhow::Result<()> {
    let old_hex_id = current_id_hex()?;
    let new_hex_id = hex::encode(new_id.as_bytes());

    if old_hex_id == new_hex_id {
        return Ok(());
    }
    // Update current
    fs::write(LAYOUT.chain_guest_id(), &new_hex_id)?;

    if id_history_hex()?.iter().any(|id| id == &new_hex_id) {
        return Ok(());
    }

    // Update history
    let history_file = OpenOptions::new()
        .create(true)
        .append(true)
        .open(LAYOUT.chain_guest_history())?;
    writeln!(&history_file, "{old_hex_id}")?;

    // Add changelog entry
    let changelog_file = OpenOptions::new()
        .create(true)
        .append(true)
        .open(LAYOUT.chain_guest_changelog())?;
    writeln!(&changelog_file, "  * `{new_hex_id}` â€“ TODO")?;

    Ok(())
}

/// Generate .rs file with current & historical chain guest IDs as const byte arrays.
pub fn generate_rust() -> anyhow::Result<()> {
    let current_id = decode_hex_id(current_id_hex()?)?;
    let history = id_history_hex()?
        .into_iter()
        .map(decode_hex_id)
        .collect::<anyhow::Result<Vec<Digest>>>()?;

    let file = File::create(LAYOUT.rust_guest_id())?;
    writeln!(&file, "// Chain guest ELF IDs. Auto-generated by build script.\n")?;
    writeln!(&file, "pub const CHAIN_GUEST_ELF_ID: [u8; 32] = {:?};\n", current_id.as_bytes())?;
    writeln!(&file, "pub const CHAIN_GUEST_OLD_ELF_IDS: [[u8; 32]; {}] = [", history.len())?;
    for old_id in history {
        writeln!(&file, "    {:?},", old_id.as_bytes())?;
    }
    writeln!(&file, "];")?;

    Ok(())
}
