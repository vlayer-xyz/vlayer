use std::{
    collections::HashMap,
    fs::{self, File, OpenOptions},
    io::{self, BufRead, BufReader, Write},
};

use risc0_build::{embed_methods_with_options, DockerOptions, GuestListEntry, GuestOptions};
use risc0_zkp::core::digest::Digest;

use crate::{
    data_layout,
    utils::{decode_hex_id, path_from_env, remove_file_if_exists, remove_guest, use_bool_var},
};

data_layout!(DataLayout {
    project_root: "../..".into(),
    target_dir: path_from_env("CARGO_TARGET_DIR").unwrap_or(project_root.join("target")),
    out_dir: path_from_env("OUT_DIR").unwrap(),
} {
    (project_root / "rust/guest_wrapper/artifacts") => artifacts_dir,
    (artifacts_dir / "chain_guest/elf_id") => chain_guest_id,
    (artifacts_dir / "chain_guest/elf_id_history") => chain_guest_history,
    (artifacts_dir / "guest_id.rs") => rust_guest_id,
    (target_dir / "assets") => solidity_assets_dir,
    (target_dir / "assets/Elf.sol") => elf_sol_output,
    (target_dir / "assets/ImageId.sol") => image_id_sol_output,
    (out_dir / "methods.rs") => rust_methods,
});

data_layout!(ExistingGuestLayout {
    artifacts_dir: path_from_env("RISC0_EXISTING_GUEST")?,
} {
    (artifacts_dir / "methods.rs") => rust_methods,
    (artifacts_dir / "ImageId.sol") => image_id_sol,
});

pub struct ChainGuestId<'a> {
    layout: &'a DataLayout,
}

impl<'a> ChainGuestId<'a> {
    pub const fn new(layout: &'a DataLayout) -> Self {
        Self { layout }
    }

    fn current_id_hex(&self) -> anyhow::Result<String> {
        let path = self.layout.chain_guest_id();
        println!("cargo::rerun-if-changed={}", path.display());
        Ok(fs::read_to_string(path)?)
    }

    fn id_history_hex(&self) -> anyhow::Result<Vec<String>> {
        let path = self.layout.chain_guest_history();
        println!("cargo::rerun-if-changed={}", path.display());
        let file = File::open(path)?;
        let reader = BufReader::new(&file);
        Ok(reader.lines().collect::<io::Result<Vec<String>>>()?)
    }

    pub fn assert(&self, generated_id: Digest) -> anyhow::Result<()> {
        let current_id = self.current_id_hex()?;
        let generated_id = hex::encode(generated_id.as_bytes());
        anyhow::ensure!(
            generated_id == current_id,
            "Chain guest ELF ID mismatch. Run with `UPDATE_GUEST_ELF_ID=1` to update."
        );
        Ok(())
    }

    pub fn update(&self, new_id: Digest) -> anyhow::Result<()> {
        let old_hex_id = self.current_id_hex()?;
        let new_hex_id = hex::encode(new_id.as_bytes());

        if old_hex_id == new_hex_id {
            return Ok(());
        }
        fs::write(self.layout.chain_guest_id(), &new_hex_id)?;

        let history = self.id_history_hex()?;
        if history.iter().any(|id| id == &new_hex_id) {
            return Ok(());
        }

        let history_file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(self.layout.chain_guest_history())?;
        writeln!(&history_file, "{old_hex_id}")?;

        Ok(())
    }

    pub fn generate_rust(&self) -> anyhow::Result<()> {
        let current_id = decode_hex_id(self.current_id_hex()?)?;
        let history = self
            .id_history_hex()?
            .into_iter()
            .map(decode_hex_id)
            .collect::<anyhow::Result<Vec<Digest>>>()?;

        let file = File::create(self.layout.rust_guest_id())?;
        writeln!(&file, "// Chain guest ELF IDs. Auto-generated by build script.\n")?;
        writeln!(&file, "pub const CHAIN_GUEST_ELF_ID: [u8; 32] = {:?};\n", current_id.as_bytes())?;
        writeln!(&file, "pub const CHAIN_GUEST_OLD_ELF_IDS: [[u8; 32]; {}] = [", history.len())?;
        for old_id in history {
            writeln!(&file, "    {:?},", old_id.as_bytes())?;
        }
        writeln!(&file, "];")?;

        Ok(())
    }
}

pub struct Builder {
    data_layout: DataLayout,
    existing_guest: Option<ExistingGuestLayout>,
    skip_build: bool,
    use_docker: bool,
    update_guest_elf: bool,
}

impl Builder {
    pub fn from_env() -> Self {
        Self {
            data_layout: DataLayout::new().unwrap(),
            existing_guest: ExistingGuestLayout::new(),
            skip_build: use_bool_var("RISC0_SKIP_BUILD"),
            use_docker: use_bool_var("RISC0_USE_DOCKER"),
            update_guest_elf: use_bool_var("UPDATE_GUEST_ELF_ID"),
        }
    }

    pub fn build(&self) -> anyhow::Result<()> {
        if self.skip_build {
            println!("cargo::warning=Skipped build of guest_wrapper");
            return Ok(());
        }

        self.prepare_assets_dir()?;

        if self.copy_existing_guest_artifacts()? {
            return Ok(());
        }

        let (call_guest, chain_guest) = self.build_guests()?;
        self.check_or_update_chain_guest_id(&chain_guest)?;
        self.generate_guest_sol_files(call_guest)?;

        Ok(())
    }

    /// Create directory for assets, clean up old artifacts.
    fn prepare_assets_dir(&self) -> io::Result<()> {
        fs::create_dir_all(self.data_layout.solidity_assets_dir())?;
        remove_file_if_exists(&self.data_layout.image_id_sol_output())?;
        remove_file_if_exists(&self.data_layout.elf_sol_output())?;
        Ok(())
    }

    /// Copy pre-built guest artifacts, if `RISC0_EXISTING_GUEST` is set.
    /// Returns true iff artifacts were copied.
    fn copy_existing_guest_artifacts(&self) -> io::Result<bool> {
        let Some(existing_guest) = self.existing_guest.as_ref() else {
            return Ok(false);
        };

        println!(
            "cargo::warning=Using existing guest artifacts from {}",
            existing_guest.artifacts_dir().display()
        );

        fs::copy(existing_guest.rust_methods(), self.data_layout.rust_methods())?;
        fs::copy(existing_guest.image_id_sol(), self.data_layout.image_id_sol_output())?;

        Ok(true)
    }

    fn get_guest_options(&self) -> GuestOptions {
        let use_docker = self.use_docker.then_some(DockerOptions {
            root_dir: Some(self.data_layout.project_root().into()),
            env: vec![
                ("CC_riscv32im_risc0_zkvm_elf".to_string(), "clang".to_string()),
                (
                    "CFLAGS_riscv32im_risc0_zkvm_elf".to_string(),
                    "-nostdlibinc -DRING_CORE_NOSTDLIBINC=1 -target riscv32-unknown-elf -march=rv32im -D__ILP32__=1".to_string()
                ),
            ],
        });
        GuestOptions {
            use_docker,
            ..Default::default()
        }
    }

    fn build_guests(&self) -> anyhow::Result<(GuestListEntry, GuestListEntry)> {
        ChainGuestId::new(&self.data_layout).generate_rust()?;
        let guest_options = self.get_guest_options();
        let mut guests = embed_methods_with_options(HashMap::from([
            ("risc0_call_guest", guest_options.clone()),
            ("risc0_chain_guest", guest_options),
        ]));
        let call_guest = remove_guest(&mut guests, "risc0_call_guest")?;
        let chain_guest = remove_guest(&mut guests, "risc0_chain_guest")?;
        Ok((call_guest, chain_guest))
    }

    /// Verify that chain guest ID is unchanged, or generate new one if `UPDATE_GUEST_ELF_ID` is set.
    /// Generate rust file with current and historical chain guest IDs.
    fn check_or_update_chain_guest_id(&self, chain_guest: &GuestListEntry) -> anyhow::Result<()> {
        let generated_id = chain_guest.image_id.into();
        let guest_id = ChainGuestId::new(&self.data_layout);

        if self.update_guest_elf {
            anyhow::ensure!(self.use_docker, "`UPDATE_GUEST_ELF_ID` requires `RISC0_USE_DOCKER`");
            guest_id.update(generated_id)?;
        } else if self.use_docker {
            guest_id.assert(generated_id)?;
        }

        Ok(())
    }

    /// Generate solidity files with call guest image ID and ELF.
    fn generate_guest_sol_files(&self, call_guest: GuestListEntry) -> anyhow::Result<()> {
        let solidity_opts = risc0_build_ethereum::Options::default()
            .with_image_id_sol_path(self.data_layout.image_id_sol_output())
            .with_elf_sol_path(self.data_layout.elf_sol_output());
        risc0_build_ethereum::generate_solidity_files(&[call_guest], &solidity_opts)?;
        Ok(())
    }
}
