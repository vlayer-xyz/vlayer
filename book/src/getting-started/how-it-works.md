# How it works?

vlayer introduces new super powers to Solidity smart contracts:

- **[Time Travel](/features/time-travel.html)**: Execute a smart contract on historical data.
- **[Teleport](/features/teleport.html)**: Execute a smart contract across different blockchain networks.
- **[Emails](/features/email.html)**: Access verified email content.
- **[Web](/features/web.html)**: Access verified web content, including APIs and websites."

## Prover and Verifier

To implement the above features, vlayer introduces two new contract types: `Prover` and `Verifier`. 

The `Prover` code runs on the vlayer zkEVM infrastructure. Proof data structure is the result of this operation.

The `Verifier` verifies generated proof and runs your code on EVM-compatible chains.

Both types of contracts are developed using the [Solidity](https://soliditylang.org) programming language.


## vlayer contract execution
A typical vlayer execution flow has three steps:
1. The application initiates a call to the Prover contract that is executed off-chain in the zkEVM. All the input for this call is private by default and is not published on-chain.
1. The result of the computation is passed along with a proof to be executed in the on-chain contract. All the output from Prover is public and is published on-chain as a parameter to the Verifier contract.
1. The Verifier contract verifies the data sent by Prover (using the submitted proof) and then executes the Verifier code.

See the diagram below.

![Off-chain execution simplified diagram](/images/offchain-execution.png)


## Prover
vlayer Prover contracts have a few distinct properties:
* **verification** - can be executed off-chain and results can't be forged
* **privacy** - inputs are private by deafult 
* **no gas fees** - no usual transaction size limits apply

> All arguments passed to the Prover contract functions are **private by default**. To make an argument public, 
 simply add it to the list of returned values.

See the example Prover contract code below. It generates proof of ownership of the very first BYAC NFT.

```solidity
contract NftOwnership is Prover  {
    function main() public returns (address) {  
      setBlockNumber(12292922); // first mints from BYAC contract 
      address owner = IERC721(BYAC_NFT_ADDR).ownerOf(1);

      require(owner == msg.sender,  "You are not owning 1st NFT");

      return (msg.sender); 
    }
}
```

In order to access Prover specific features, your contract needs to derive from the vlayer Prover contract. Then `setBlockNumber()` [time travels](/features/time-travel.html) context to a historic block in which the first mint of BYAC NFT occurred. `require` makes sure that the caller (`msg.sender`) was the owner of the 1st token at that point of time. The caller address is returned, which makes it public input for the Verifier contract. 

## Verifier 
The Verifier smart contract [validates the correctness](/appendix/architecture/solidity.html) of a computation generated by Prover, without revealing the underlying information. Such contracts can be used to facilitate more complex workflows, such as privacy-preserving decentralized finance (DeFi) applications or confidential voting systems.

Verification logic is immutable once deployed on the blockchain, ensuring consistent and permissionless access.

See the example `Verifer` contract below. It transfers tokens to proven owner of certain NFT: 


```solidity
address NFT_OWNERSHIP_VLAYER_CONTRACT = 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d;

contract Airdrop is Verifier {
  function claim(Proof calldata proof, address owner) 
    public 
    onlyVerified(NFT_OWNERSHIP_VLAYER_CONTRACT, NftOwnership.main.selector) 
  {
    IAwesomeToken(TOKEN_ADDR).transfer(owner, 1000);
  }
}
```
Note that the above contract inherits from the `Verfier` vlayer contract. 
It is necessary for veryfing the computation done by the Prover contract from the previous step. 

`claim()` function takes proof returned by the vlayer SDK as the first argument. Other arguments are public inputs returned from Prover `main()` function (in the same order). 

`onlyVerified(address, bytes4)` modifier ensures that proof is valid and takes two arguments:
- Address of the Prover contract 
- Function selector of the Prover main function

`Proof` doesn't have to be passed to `onlyVerified` as argument because it is automatically extracted from `msg.data`

--- 

To learn more about how the `Prover` and `Verifier` work under the hood, please refer to [our appendix](/appendix/architecture/prover.html).