# How it works?
vlayer introduces two new types of contracts: Prover and Verifier. The Prover code runs on the vlayer zkEVM infrastructure and Verifier can be executed on EVM-compatible chains. Both types of contracts have to be developed using [Solidity](https://soliditylang.org) programming language.

## Features
Compared to regular contracts, vlayer smart contracts introdcues new features such as:
* **[time travel](/features/time-travel.html)** - ability to execute smart contracts on historical data
* **[teleport](/features/teleport.html)** - ability to execute smart contracts in the context of different chains
* **[emails](/features/email.html)** - access to verfied content of emails
* **[web](/features/web.html)** - access to verified web content (APIs and websites)

## vlayer contract execution
A typical vlayer execution flow has three steps:
1. The application initiates a call to the Prover contract that is executed off-chain in the zkEVM. All the input for this call is private by default and is not published on-chain.
1. The result of the computation is passed along with a proof to be executed in the on-chain contract. All the output from Prover is public and is published on-chain as a parameter to the Verifier contract.
1. The Verifier contract verifies the data sent by Prover (using the submitted proof) and then executes the Verifier code.

See the diagram below.

![Off-chain execution simplified diagram](/images/offchain-execution.png)


## Prover
vlayer Prover contracts have the a few distinct properties:
* **verification** - can be verified off-chain and results can't be forged
* **privacy** - inputs are private by deafult 
* **no gas fees** and no usual transaction size limits apply

> All arguments passed to the Prover contract functions are **private by default**. To make an argument public, 
 simply add it to the list of returned values.

See the example Prover contract code below. It generates proof of ownership of the very first BYAC NFT.

```solidity
contract NftOwnership is Prover  {
    function main() public returns (address) {  
      setBlockNumber(12292922); // first mints from BYAC contract 
      address owner = IERC721(BYAC_NFT_ADDR).ownerOf(1);

      require(owner == msg.sender,  "You are not owning 1st NFT");

      return (msg.sender); 
    }
}
```

In order to generate proof, your contract needs to derive from the vlayer Prover contract. Then `setBlockNumber()` [time travels](/features/time-travel.html) context to a historic block in which the first mint of BYAC NFT occurred. `require` makes sure that the caller (`msg.sender`) was the owner of the 1st token at that point of time. The caller address is returned, which makes it public input for the Verifier contract. 

## Verifier 
The Verifier smart contract [validates the correctness](/appendix/architecture/solidity.html) of a computation generated by Prover, without revealing the underlying information. Such contracts can be used to facilitate more complex workflows, such as privacy-preserving decentralized finance (DeFi) applications or confidential voting systems.

Verification logic is immutable once deployed on the blockchain, ensuring consistent and permissionless access.

See the example Verifer contract below:


```solidity
address NFT_OWNERSHIP_VLAYER_CONTRACT = 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d;

contract Airdrop is Verifier {
  function claimOnce(Proof calldata proof, address owner) 
    public 
    onlyVerified(NFT_OWNERSHIP_VLAYER_CONTRACT, NftOwnership.main.selector) 
  {
    IAwesomeToken(TOKEN_ADDR).transfer(sender, 1000);
  }
}
```
Note that the above contract inherits from the `Verfier` vlayer contract. 
It is necessary for veryfing the computation done by the Prover contract from the previous step. 

`claimOnce()` function takes proof returned by the vlayer SDK as the first argument. Other arguments are public inputs returned from Prover `main()` function (in the same order). 

`onlyVerified(address, bytes4)` modifier ensures that proof is valid and takes two arguments:
- Address of the Prover contract 
- Function selector of the Prover main function

`Proof` doesn't have to be passed to `onlyVerified` as argument because it is automatically extracted from `msg.data`