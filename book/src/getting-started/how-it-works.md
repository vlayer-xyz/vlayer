# How it works?
Vlayer contracts are just like regular on-chain contracts written in [Solidity](https://soliditylang.org). The main difference is the execution model, as bytecode is executed on the vlayer zkEVM infrastructure. 

## Features

Compared to regular contracts, vlayer smart contracts have additional features such as:
* **[time travel](/features/time-travel.html)** - ability to execute smart contracts on historaical data
* **[teleport](/features/teleport.html)** - ability to execute smart contracts in the context of different chains
* **web content** - access to verified web content (APIs and websites)
* **emails** - access to verfied content of email

![Off-chain execution simplified diagram](/images/offchain-execution.png)

Above diagram ilustrates how typical vlayer execution flow looks:
1. App sends private inputs to Prover contract. 
1. Prover code runs at zkEVM and returns proof of proper execution with public inputs
1. App submits the generated proof and any necessary public inputs to the Verifier smart contract on the EVM compatible chain.

## Prover

vlayer Prover contracts have the following features:
* Verification - zkEVM's off-chain execution produces cryptographic proofs
* Built-in privacy - inputs are private and never available to the public
* No gas fees and no transaction size limits

> All arguments passed to the contract functions are **private by default**. 
If you need to make certain arguments public outside of the validator contract, simply return them from the validator function.

Example Prover code: 

```solidity
contract NftOwnership is VlayerProver  {

    function require_byac_nft() public view {
      require(
        IERC721(BYAC_NFT_ADDR).balanceOf(msg.sender) > 0, 
        "You are not owning required NFT"
      );
    } 

    function main() public returns (address) {  
      setChainId(1); 
      setBlockNumber(21_000_000); 

      require_byac_nft();

      // anything returned here would be visible to the public
      return (msg.sender); 
    }
}
```

## Verifier 

The Verifier smart contract [validates the correctness](/appendix/architecture/solidity.html) of a proof generated by Prover, without revealing the underlying information. Such contracts can be used to facilitate more complex workflows, such as privacy-preserving decentralized finance (DeFi) applications or confidential voting systems.

Verification logic is immutable once deployed on the blockchain, ensuring consistent and permissionless access.

Example contract with proof verification: 

```solidity
contract Airdrop is VlayerVerifier {
  mapping (address => bool) public withdrawn;

  function claim(Proof calldata proof, address sender) public 
    onlyVerified(NFT_OWNERSHIP_VLAYER_CONTRACT) 
  {
    require(withdrawn[sender] == false, "Already withdrawn");

    withdrawn[sender] = true;
    IAwesomeToken(TOKEN_ADDR).transfer(sender, 1000);
  }
}
```

Note that as a developer you don't need to worry too much about `Proof calldata proof`. Proof is automatically validated thanks to `onlyVerified` modifier exposed by our SDK.
All you have to do is just provide your custom business logic.

