# How it works?
vlayer introduces two new types of contracts: Prover and Verifier. Prover code runs on the vlayer zkEVM infrastructure and Verifier can be executed on EVM-compatible chains. Both types of contracts have to be developed using [Solidity](https://soliditylang.org) programming language.

## Features
Compared to regular contracts, vlayer smart contracts introdcues new features such as:
* **[time travel](/features/time-travel.html)** - ability to execute smart contracts on historical data
* **[teleport](/features/teleport.html)** - ability to execute smart contracts in the context of different chains
* **web content** - access to verified web content (APIs and websites)
* **emails** - access to verfied content of email

## vlayer contract execution
A typical vlayer execution flow have three steps:
1. Application initiates a call to a Prover contract that is executed off-chain in the zkEVM. All input for this call is private by default and is not published on-chain.
1. The result of the computation is passed along with a proof to be executed in the on-chain contract. All output from the Prover is public and is published on-chain as a parameter to the Verifier contract.
1. The Verifier contract verifies the data sent by the Prover (using the submitted proof) and then executes the Verifier code.

See the diagram below.

![Off-chain execution simplified diagram](/images/offchain-execution.png)


## Prover
vlayer Prover contracts have the a few distinct properties:
* **verification** - can be verified off-chain and results can't be forged
* **privacy** - inputs are private by deafult 
* **no gas fees** and usual transaction size limits apply

> All arguments passed to the Prover contract functions are **private by default**. To make an argument public, 
 simply add it to the list of returned values.

See example Prover contract code below. It generates proof of ownership of the very first BYAC NFT.

```solidity
contract NftOwnership is Prover  {
    function require_first_byac_nft() public view {
      require(
        IERC721(BYAC_NFT_ADDR).ownerOf(1) == msg.sender, 
        "You are not owning 1st NFT"
      );
    } 

    function main() public returns (address) {  
      setBlockNumber(12292922); // first mints from BYAC contract 
      require_first_byac_nft();
      return (msg.sender); 
    }
}
```

In order to generate proof your contract needs to derive from vlayer Prover contract. Then `setBlockNumber()` [time travels](/features/time-travel.html) context to historic block in which first mints of BYAC NFT happened. `require_first_byac_nft()` makes sure that caller (`msg.sender`) was owner of the 1st token in that point of time. Caller address is returned which makes it public input for Verifier contract. 

## Verifier 
The Verifier smart contract [validates the correctness](/appendix/architecture/solidity.html) of a computation generated by Prover, without revealing the underlying information. Such contracts can be used to facilitate more complex workflows, such as privacy-preserving decentralized finance (DeFi) applications or confidential voting systems.

Verification logic is immutable once deployed on the blockchain, ensuring consistent and permissionless access.

See example Verifer contract below.


```solidity
address NFT_OWNERSHIP_VLAYER_CONTRACT = 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d;
bytes4 constant FUNCTION_SELECTOR = bytes4(keccak256(abi.encodePacked("main()")));

contract Airdrop is Verifier {
  function claimOnce(Proof calldata proof, address owner) public 
    onlyVerified(NFT_OWNERSHIP_VLAYER_CONTRACT, FUNCTION_SELECTOR) 
  {
    IAwesomeToken(TOKEN_ADDR).transfer(sender, 1000);
  }
}
```
Note that the above contract inherits from `Verfier` vlayer contract. 
It is necessary for veryfing computation done by prover contract from previous step. 

`claimOnce()` function takes proof returned by vlayer SDK as a first argument. Other arguments are public inputs returned from Prover `main()` function (in the same order). 

`onlyVerified(address, bytes4)` modifier ensures that proof is valid and takes two arguments:
- Address of the Prover contract 
- Function selector of Prover main function

